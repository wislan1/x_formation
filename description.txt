solution is under the following link:

https://github.com/wislan1/x_formation.git


Question 1
(this task was tested in mySQl)


I. Selects names of all buildings in Poland
-----------------------------------------
SELECT Building.Name
FROM Country INNER JOIN City 
ON Country.CountryID=City.CountryID
INNER JOIN Building
ON City.CityID=Building.CityID
WHERE Country.Name='Poland'
ORDER BY Building.Name;

SELECT Building.Name
FROM Country, City, Building
WHERE Country.Name='Poland'
AND Country.CountryID=City.CountryID
AND City.CityID=Building.CityID
ORDER BY Building.Name;



II. Selects countries where a total number of inhabitants (population) in all the cities is
greater than 400
---------------------------------------------------------------------------

SELECT Country.Name, SUM(City.Population) AS PopSum
FROM Country INNER JOIN City 
ON Country.CountryID=City.CountryID
GROUP BY Country.Name
HAVING PopSum>400;


//***************************************************************


Question 2 (this was tested in g++ 4.8.3)

There is no assignment operator, copy constructor and possibly default constroctor in the Array class.
There is no memory leak handling in constructor and wrong operator to free memory in destructor



A)
When we will use
Array a1(10), a2(2);
a1=a2;//assignment operator

default assigment operator will be generated by compiler (memberwise copy)
which will assign only address of a2.m_pData to a1.m_pData so the both will point to the same address. No separate free store will be alocated for a1.m_pData.
When all Array objects will go out of the range and destructors will be run then
for every allocated pointer, a destructor will be caled two times (once for a1 and once for a2), so to attempt two times release the memory.
This will cause memory leak problem; This problem can be tested in valgrind or purify;

To fix this problem an assigment operator like this should be defined;
Array& operator=(const Array& c)
{
if(m_pData != NULL)
delete [] m_pData;

m_pData=new T[c.m_nSize];
for(int i=0;i<c.m_nSize;i++)
m_pData[i]=c.m_pData[i];
//update size
m_nSize=c.m_nSize;

return *this;
}



B)
In situation
Array a1(10);
Array a2=a1;//copy constructor

default copy constructor will be generated by compiler (memberwise copy)
which will assign only address of a1.m_pData to a2.m_pData so the both will point to the same address. No separate free store will be alocated for a2.m_pData.
When all Array objects will go out of the range and destructors will be run then
for every allocated pointer, a destructor will be caled two times (once for a1 and once for a2), so to attempt two times release the memory.
This will cause memory leak problem; This problem can be tested in valgrind or purify;
To fix this problem a copy constructor like this should be defined;
Array(const Array& c)
{

m_pData=new T[c.m_nSize];
for(int i=0;i<c.m_nSize;i++)
m_pData[i]=c.m_pData[i];
//set the size
m_nSize=c.m_nSize;

}



C)
In situation
Array a1;//default constructor
It result in compilation error, because no default constructor exists.

To fix this problem we can change the head of constructor to:
Array(unsigned int nSize=10) : m_nSize(nSize)


d)
In the destructor it should be used "delete [] m_pData" operator to prevent memory leak
This problem can be tested in valgrind or purify

virtual ~Array()
{
if(m_pData != NULL)
delete m_pData;
}

e)
This "new nothrow" operator will suppress throwing std::bad_alloc exception
so m_pData have to be checked agains the NULL and apropriate handling for it

To test this, we can allocate huge amount of memory more then available in the system it works,
then the program will crash.

Array(unsigned int nSize) : m_nSize(nSize)
{
if(m_nSize > 0)
m_pData = new (nothrow) T[m_nSize];
}

we may as well use following code but throwing exception from constructor is not advisable:

    try
    {//in following code we call default constructor of class T
      m_pData = new T[m_nSize];
    }
    catch (std::bad_alloc &ba)
    {
       cout<<"allocation failure!\n";
       //...additional cleanup
       // we may rethrow the exception up
       throw;
    }

