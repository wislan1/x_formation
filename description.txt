Question 1
(this task was tested in mySQl)


I. Selects names of all buildings in Poland
-----------------------------------------
SELECT Building.Name
FROM Country INNER JOIN City 
ON Country.CountryID=City.CountryID
INNER JOIN Building
ON City.CityID=Building.CityID
WHERE Country.Name='Poland'
ORDER BY Building.Name;

SELECT Building.Name
FROM Country, City, Building
WHERE Country.Name='Poland'
AND Country.CountryID=City.CountryID
AND City.CityID=Building.CityID
ORDER BY Building.Name;



II. Selects countries where a total number of inhabitants (population) in all the cities is
greater than 400
---------------------------------------------------------------------------

SELECT Country.Name, SUM(City.Population) AS PopSum
FROM Country INNER JOIN City 
ON Country.CountryID=City.CountryID
GROUP BY Country.Name
HAVING PopSum>400;


//***************************************************************


Question 2

There is no assignment operator, copy constructor and possibly default constroctor in the Array class.
There is no memory leak handling in constructor and wrong operator to free memory in destructor



A)
When we will use
Array a1(10), a2(2);
a1=a2;//assignment operator

default assigment operator will be generated by compiler (memberwise copy)
which will assign only address of a2.m_pData to a1.m_pData so the both will point to the same address. No separate free store will be alocated for a1.m_pData.
When all Array objects will go out of the range and destructors will be run then
for every allocated pointer, a destructor will be caled two times (once for a1 and once for a2), so to attempt two times release the memory.
This will cause memory leak problem; This problem can be tested in valgrind or purify;

To fix this problem an assigment operator like this should be defined;
Array& operator=(const Array& c)
{
if(m_pData != NULL)
delete [] m_pData;

m_pData=new T[c.m_nSize];
for(int i=0;i<c.m_nSize;i++)
m_pData[i]=c.m_pData[i];
//update size
m_nSize=c.m_nSize;

return *this;
}



B)
In situation
Array a1(10);
Array a2=a1;//copy constructor

default copy constructor will be generated by compiler (memberwise copy)
which will assign only address of a1.m_pData to a2.m_pData so the both will point to the same address. No separate free store will be alocated for a2.m_pData.
When all Array objects will go out of the range and destructors will be run then
for every allocated pointer, a destructor will be caled two times (once for a1 and once for a2), so to attempt two times release the memory.
This will cause memory leak problem; This problem can be tested in valgrind or purify;
To fix this problem a copy constructor like this should be defined;
Array(const Array& c)
{

m_pData=new T[c.m_nSize];
for(int i=0;i<c.m_nSize;i++)
m_pData[i]=c.m_pData[i];
//set the size
m_nSize=c.m_nSize;

}



C)
In situation
Array a1;//default constructor
It result in compilation error, because no default constructor exists.

To fix this problem we can change the head of constructor to:
Array(unsigned int nSize=10) : m_nSize(nSize)


d)
In the destructor it should be used "delete [] m_pData" operator to prevent memory leak
This problem can be tested in valgrind or purify

virtual ~Array()
{
if(m_pData != NULL)
delete m_pData;
}

e)
This "new nothrow" operator will suppress throwing std::bad_alloc exception
so m_pData have to be checked agains the NULL and apropriate handling for it

To test this, we can allocate huge amount of memory more then available in the system it works,
then the program will crash.

Array(unsigned int nSize) : m_nSize(nSize)
{
if(m_nSize > 0)
m_pData = new (nothrow) T[m_nSize];
}

to fix this problem we can change to following code:

    try
    {//in following code we call default constructor of class T
      m_pData = new T[m_nSize];
    }
    catch (std::bad_alloc &ba)
    {
       cout<<"allocation failure!\n";
       //...additional cleanup
       // we may rethrow the exception up
       throw;
    }






//-----------------------------------------
// ---- HERE IS CORRECTED CODE START-------

#include <iostream>
#include <stdio.h>

using namespace std;


template <class T>
class Array
{
private:
  T *m_pData; //we must ensure not to pass T& as a parameter
  unsigned int m_nSize;
public:
  Array(unsigned int nSize=5) : m_nSize(nSize)
  {

  //To test it we can allocate huge amount of memory more then
  //that available on the heap, program then crashes.
  //when we have to use legacy code we may update it like this.
  /*
    if(m_nSize > 0)
    {//in following code we call default constructor of class T
      m_pData = new (nothrow) T[m_nSize];
      if(m_pData==NULL)
      {
        cout<<"allocation failure!"
        exit(1);
      }
    }
  //*/
  //or better we use following code
    try
    {//in following code we call default constructor of class T
      m_pData = new T[m_nSize];
    }
    catch (std::bad_alloc &ba)
    {
       cout<<"allocation failure!\n";
       //...additional cleanup
       // we may rethrow the exception up
       throw;
    }
  }
//copy constructor
  Array(const Array& c)
  {
    m_pData=new T[c.m_nSize];
    for(int i=0;i<c.m_nSize;i++)
    m_pData[i]=c.m_pData[i];
    //set the size
    m_nSize=c.m_nSize;
  }

//assignment operator
  Array& operator=(const Array& c)
  {
    if(m_pData != NULL)
    delete [] m_pData;

    m_pData=new T[c.m_nSize];
    for(int i=0;i<c.m_nSize;i++)
    m_pData[i]=c.m_pData[i];
    //update size
    m_nSize=c.m_nSize;

  return *this;
  }

  virtual ~Array()
  {
    if(m_pData != NULL)
    //call apropriate operator - delete [], not delete
    //we can test it with: valgrind --tool=memcheck
    //or purify
      delete [] m_pData;
  }

  bool Set(unsigned int nPos, const T& Value)
  {
    if(nPos < m_nSize)
    {
    //in following code an assignment operator for class T will be called
    //so if we did not define one, a default will be generated by compiler
    //we must be sure if this is what we really want.
      m_pData[nPos] = Value;
      return true;
    }
    else
      return false;
  }

  T Get(unsigned int nPos)
  {
    if(nPos < m_nSize)
    //in following code we call copy constructor of class T
    //so we have to ensure if we really defined it or
    //if a one generated by compiler is the right one.
      return m_pData[nPos];
    else
    //in following code we call default constructor of class T
    //so we have to ensure if we really defined it or
    //if it can be generated automtically by compilator
      return T();
  }

};

//-----------------------------------
//--------For testing----------------

class MyClass
{
public:

  MyClass(int i)
  {
    cout<<"MyClass int "<<++myCount<<"\n";
  }

  MyClass()
  {
    cout<<"MyClass default "<<++myCount<<"\n";
  }

  MyClass(const MyClass& cl)
  {
    cout<<"MyClass CopyConstructor "<<++myCount<<"\n";
  }

  MyClass& operator=(const MyClass& cl)
  {
    cout<<"MyClass Assignment\n";

  return *this;
  }

  ~MyClass()
  {
    cout<<"~MyClass "<<--myCount<<"\n";
  }

static int myCount;

};




//---------------------------------------------------------------------------
int MyClass::myCount=0;


int main(int argc, char* argv[])
{

//*
cout<<"assignment operator test start\n\n";
{
  cout<<"---create two Array<MyClass> 10 and 2 elements\n";
  Array<MyClass> a1(10), a2(2);
  cout<<"---assign operator on Array<MyClass>\n";
  a1=a2;//assignment operator
  cout<<"---eof local scope\n";
}
cout<<"assignment operator test stop\n\n";
//*/

/*
cout<<"copy constructor test start\n\n";
{
  cout<<"---create Array<MyClass> 10 elements\n";
  Array<MyClass> a3(10);
  cout<<"---copy constructor on Array<MyClass> of 10 elements\n";
  Array<MyClass> a4=a3;//copy constructor
  cout<<"---eof local scope\n";
}
cout<<"copy constructor test stop\n\n";
//*/


/*
  cout<<"Get, Set test start"<<endl<<endl;
  {//locall scope
  MyClass tmpObj;
  //handle Get and Set functions
  Array<MyClass> arrObj(5);
  cout<<"---Set() within the table\n";
  arrObj.Set(4,tmpObj);
  cout<<"---Get() within the table\n";
  arrObj.Get(3);
  cout<<"---Get() outside the table\n";
  arrObj.Get(5);
  cout<<"---eof local scope\n";
  }//locall scope
  cout<<"Get, Set test stop"<<endl;//*/
  getchar();

return 0;
}


//-----------------------------------------
// ---- HERE IS CORRECTED CODE END --------
