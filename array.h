#if !defined( ARRAY_H )
#define ARRAY_H

#include <iostream>
#include <stdio.h>
#include <cstdlib>


using namespace std;


template <class T>
class Array
{
private:
  T *m_pData; //we must ensure not to pass T& as a parameter
  unsigned int m_nSize;
public:
  Array(unsigned int nSize=5) : m_nSize(nSize)
  {

  //To test it we can allocate huge amount of memory more then
  //that available on the heap, program then crashes.
  //when we have to use legacy code we may update it like this.
  //*
    if(m_nSize > 0)
    {//in following code we call default constructor of class T
      m_pData = new (nothrow) T[m_nSize];
      if(m_pData==NULL)
      {
        cout<<"allocation failure!";
        exit(1);
      }
    }
  //*/

/*
  //we may as well use following code but throwing exception from constructor is not advisable
    try
    {//in following code we call default constructor of class T
      m_pData = new T[m_nSize];
    }
    catch (std::bad_alloc &ba)
    {
       cout<<"allocation failure!\n";
       //...additional cleanup
       // we may rethrow the exception up
       throw;
    }
	//*/
  }

//copy constructor
  Array(const Array& c)
  {
    m_pData=new T[c.m_nSize];
    for(int i=0;i<c.m_nSize;i++)
    m_pData[i]=c.m_pData[i];
    //set the size
    m_nSize=c.m_nSize;
  }

//assignment operator
  Array& operator=(const Array& c)
  {
    if(m_pData != NULL)
    delete [] m_pData;

    m_pData=new T[c.m_nSize];
    for(int i=0;i<c.m_nSize;i++)
    m_pData[i]=c.m_pData[i];
    //update size
    m_nSize=c.m_nSize;

  return *this;
  }

  virtual ~Array()
  {
    if(m_pData != NULL)
    //call apropriate operator - delete [], not delete
    //we can test it with: valgrind --tool=memcheck
    //or purify
      delete [] m_pData;
  }

  bool Set(unsigned int nPos, const T& Value)
  {
    if(nPos < m_nSize)
    {
    //in following code an assignment operator for class T will be called
    //so if we did not define one, a default will be generated by compiler
    //we must be sure if this is what we really want.
      m_pData[nPos] = Value;
      return true;
    }
    else
      return false;
  }

  T Get(unsigned int nPos)
  {
    if(nPos < m_nSize)
    //in following code we call copy constructor of class T
    //so we have to ensure if we really defined it or
    //if a one generated by compiler is the right one.
      return m_pData[nPos];
    else
    //in following code we call default constructor of class T
    //so we have to ensure if we really defined it or
    //if it can be generated automtically by compilator
      return T();
  }

};

#endif // !defined( ARRAY_H )
